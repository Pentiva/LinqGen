// LinqGen.Generator, Maxwell Keonwoo Kang <code.athei@gmail.com>, 2022

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;

namespace Cathei.LinqGen.Generator
{
    public static class Template
    {
        private const string CommonHeaderStr = @"// DO NOT EDIT
// Generated by LinqGen.Generator

using System;
using System.Collections;
using System.Collections.Generic;
using Cathei.LinqGen;
using Cathei.LinqGen.Hidden;
";

        /// <summary>
        /// Enumerable is always and must be internal as it is generated.
        /// Also define as readonly struct so to prevent possible mutation.
        /// And also get performance benefit passing with in parameter.
        /// </summary>
        private const string EnumerableHeaderStr = @"
namespace Cathei.LinqGen.Hidden
{{
    // enumerable is always readonly and internal as it is generated struct
    internal readonly struct {0} : IStub<{1}, NoOp>
    {{
";

        private const string EnumerableMemberStr = @"
        private readonly {0} {1};
";

        private const string EnumerableConstructorHeaderStr = @"
        internal {0}(";

        private const string EnumerableConstructorBodyStr = @")
        {";

        private const string EnumerableConstructorAssignStr = @"
            this.{1} = {1};";

        private const string EnumerableConstructorFooterStr = @"
        }
";

        private const string EnumerableGetEnumeratorStr = @"
        public Enumerator GetEnumerator() => new Enumerator(this);
";

        private const string EnumeratorHeaderStr = @"
        public struct Enumerator : IEnumerator<{0}>
        {{
";

        private const string EnumeratorConstructorHeaderStr = @"
            internal Enumerator(in {0} e)
            {{
";

        private const string EnumeratorConstructorAssignStr = @"
                this.{1} = e.{1};";

        private const string EnumeratorConstructorFooterStr = @"
            }
";

        private const string EnumeratorMoveNextHeaderStr = @"
            public bool MoveNext()
            {
                ";

        private const string EnumeratorMoveNextFooterStr = @"
            }";

        private const string EnumeratorGetCurrentHeaderStr = @"
            public {0} Current
            {{
                get
                {{
                    ";

        private const string EnumeratorGetCurrentFooterStr = @"
                }
            }

            object IEnumerator.Current => Current;
";

        private const string EnumeratorResetStr = @"
            void IEnumerator.Reset() => throw new NotSupportedException();
";

        private const string EnumeratorDisposeHeaderStr = @"
            public void Dispose()
            {
                ";

        private const string EnumeratorDisposeFooterStr = @"
            }";

        private const string EnumeratorMemberStr = @"
            private {0} {1};
";

        private const string EnumeratorFooterStr = @"
        }
";

        private const string EnumerableFooterStr = @"
    }
}
";

        /// <summary>
        /// Extensions is always and must be internal as it is generated.
        /// We cannot bring operation metadata to generate if it's built in other assembly.
        /// So it is required to build each LinqGen in each assembly.
        /// </summary>
        private const string ExtensionsHeaderStr = @"
namespace Cathei.LinqGen
{{
    // Extensions is always and must be internal as it is generated
    internal static partial class LinqGenExtensions_{0}
    {{
";

        /// <summary>
        /// Assume that first member is the enumerable source
        /// </summary>
        private const string ExtensionsMethodHeaderStr = @"
        public static {0} {1}(this ";

        private const string ExtensionsMethodReturnStr = @")
        {{
            return new {0}(";

        private const string ExtensionsMethodFooterStr = @");
        }
";

        private const string ExtensionsFooterStr = @"
    }
}
";

        [Flags]
        public enum MemberKind
        {
            Enumerable = 1,
            Enumerator = 2,
            Both = Enumerable | Enumerator
        }

        public readonly struct MemberInfo
        {
            public readonly MemberKind Kind;
            public readonly string TypeStr;
            public readonly string NameStr;

            public MemberInfo(MemberKind kind, string typeStr, string nameStr)
            {
                Kind = kind;
                TypeStr = typeStr;
                NameStr = nameStr;
            }
        }


        public static void Render(StringBuilder builder, Node node)
        {
            var memberInfos = node.GetMemberInfos().ToList();

            builder.Clear();
            builder.Append(CommonHeaderStr);

            builder.AppendFormat(EnumerableHeaderStr, node.ClassName, node.ElementName);
            {
                FormatMemberInfo(builder, EnumerableMemberStr, null, memberInfos, MemberKind.Enumerable);

                builder.AppendFormat(EnumerableConstructorHeaderStr, node.ClassName);
                {
                    FormatMemberInfo(builder, "{0} {1}", ", ",
                        memberInfos, MemberKind.Enumerable);
                    builder.Append(EnumerableConstructorBodyStr);
                    FormatMemberInfo(builder, EnumerableConstructorAssignStr, null,
                        memberInfos, MemberKind.Enumerable);
                }
                builder.Append(EnumerableConstructorFooterStr);

                builder.Append(EnumerableGetEnumeratorStr);

                builder.AppendFormat(EnumeratorHeaderStr, node.ElementName);
                {
                    FormatMemberInfo(builder, EnumeratorMemberStr, null,
                        memberInfos, MemberKind.Enumerator);

                    builder.AppendFormat(EnumeratorConstructorHeaderStr, node.ClassName);
                    {
                        // copy if both are member
                        FormatMemberInfo(builder, EnumeratorConstructorAssignStr, null,
                            memberInfos, MemberKind.Both);

                        // additional constructor body
                        node.RenderConstructorBody(builder);
                    }
                    builder.Append(EnumeratorConstructorFooterStr);

                    builder.Append(EnumeratorMoveNextHeaderStr);
                    {
                        node.RenderMoveNextBody(builder);
                    }
                    builder.Append(EnumeratorMoveNextFooterStr);

                    builder.AppendFormat(EnumeratorGetCurrentHeaderStr, node.ElementName);
                    {
                        node.RenderGetCurrentBody(builder);
                    }
                    builder.Append(EnumeratorGetCurrentFooterStr);

                    builder.Append(EnumeratorResetStr);

                    builder.Append(EnumeratorDisposeHeaderStr);
                    {
                        node.RenderDisposeBody(builder);
                    }
                    builder.Append(EnumeratorDisposeFooterStr);
                }
                builder.Append(EnumeratorFooterStr);
            }
            builder.Append(EnumerableFooterStr);

            builder.AppendFormat(ExtensionsHeaderStr, node.ClassName);
            {
                builder.AppendFormat(ExtensionsMethodHeaderStr, node.ClassName, node.MethodName);
                {
                    FormatMemberInfo(builder, "{0} {1}", ", ", memberInfos, MemberKind.Enumerable);
                    builder.AppendFormat(ExtensionsMethodReturnStr, node.ClassName);
                    FormatMemberInfo(builder, "{1}", ", ", memberInfos, MemberKind.Enumerable);
                }
                builder.Append(ExtensionsMethodFooterStr);
            }
            builder.Append(ExtensionsFooterStr);
        }

        private static void FormatMemberInfo(
            StringBuilder builder, string format, string? separator, List<MemberInfo> memberInfos, MemberKind kind)
        {
            bool first = true;

            foreach (var memberInfo in memberInfos)
            {
                if ((memberInfo.Kind & kind) != kind)
                    continue;

                if (!first && separator != null)
                    builder.Append(separator);

                first = false;
                builder.AppendFormat(format, memberInfo.TypeStr, memberInfo.NameStr);
            }
        }
    }
}