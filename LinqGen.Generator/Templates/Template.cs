// LinqGen.Generator, Maxwell Keonwoo Kang <code.athei@gmail.com>, 2022

using System;
using System.Text;
using Microsoft.CodeAnalysis;

namespace Cathei.LinqGen.Generator
{
    public static class Template
    {
        public const string CommonHeaderStr = @"// DO NOT EDIT
// Generated by LinqGen.Generator

using System;
using System.Collections.Generic;
using Cathei.LinqGen;
using Cathei.LinqGen.Hidden;
";

        /// <summary>
        /// Enumerable is always and must be internal as it is generated.
        /// Also define as readonly struct so to prevent possible mutation.
        /// And also get performance benefit passing with in parameter.
        /// </summary>
        public const string EnumerableHeaderStr = @"
namespace Cathei.LinqGen.Hidden
{{
    // enumerable is always readonly and internal as it is generated struct
    internal readonly struct {0}_{1} :
        ILinqGenEnumerable<{2}, NoOp>
    {{
";

        public const string EnumerableMemberStr = @"
        private readonly {0} {1};
";

        public const string EnumeratorHeaderStr = @"
        public struct Enumerator
        {
";

        public const string EnumeratorConstructorHeaderStr = @"
            internal Enumerator(in {0}_{1} enumerable)
            {{
";

        public const string EnumeratorConstructorIncludeEnumerableStr = @"
                this.e = enumerable;
";

        public const string EnumeratorConstructorFooterStr = @"
            }
";

        public const string EnumeratorMemberIncludeEnumerableStr = @"
            private readonly {0}_{1} e;
";

        public const string EnumeratorMemberStr = @"
            private readonly {0} {1};
";

        public const string EnumeratorFooterStr = @"
        }
";

        public const string EnumerableGetEnumeratorStr = @"
        public Enumerator GetEnumerator() => new Enumerator(this);
";

        public const string EnumerableFooterStr = @"
    }
}
";

        /// <summary>
        /// Extensions is always and must be internal as it is generated.
        /// We cannot bring operation metadata to generate if it's built in other assembly.
        /// So it is required to build each LinqGen in each assembly.
        /// </summary>
        public const string ExtensionsHeaderStr = @"
namespace Cathei.LinqGen
{
    // Extensions is always and must be internal as it is generated
    internal static partial class LinqGenExtensions
    {
";

        public const string ExtensionsMethodHeaderStr = @"
        public static {0}_{1} {2}(";

        /// <summary>
        /// Needs to be joined with ,
        /// </summary>
        public const string ExtensionsMethodParameterStr = @"{0} {1}";

        public const string ExtensionsMethodReturnStr = @")
        {{
            return new {0}_{1}(
";

        public const string ExtensionsMethodFooterStr = @");
        }
";

        public const string ExtensionsFooterStr = @"
    }
}
";



        private const string SourceTemplate = @"// DO NOT EDIT
// Generated by LinqGen.Generator

using System.Collections.Generic;

namespace Cathei.LinqGen.Hidden
{{
    using Operations;

    public readonly struct {0}_{1} : ILinqGenEnumerable<{2}, NoOp>
    {{
        private readonly IEnumerable<{2}> source;

        internal {0}_{1}(IEnumerable<{2}> source)
        {{
            this.source = source;
        }}

        public IEnumerator<{2}> GetEnumerator() => source.GetEnumerator();
    }}
}}

namespace Cathei.LinqGen
{{
    public static partial class LinqGenExtensions
    {{
        public static {0}_{1} Generate(this IEnumerable<{2}> source)
            => new {0}_{1}(source);
    }}
}}
";

        public readonly struct MemberInfo
        {
            public readonly string TypeStr;
            public readonly string NameStr;

            public MemberInfo(string typeStr, string nameStr)
            {
                TypeStr = typeStr;
                NameStr = nameStr;
            }
        }


        public static void Render(StringBuilder builder, GenerationItem item, int id)
        {
            string shortName = Constants.Op.ShortName[Constants.Op.Gen];
            string elementFullName = item.ElementTypeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            builder.AppendFormat(SourceTemplate, shortName, id, elementFullName);
        }
    }
}